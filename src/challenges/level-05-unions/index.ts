import { LevelDefinition } from '../../engine/types';

export const level05: LevelDefinition = {
  number: 5,
  title: 'Unions & Narrowing',
  description:
    'Master union types, discriminated unions, and type narrowing — the tools that let TypeScript understand your runtime logic at compile time.',
  challenges: [
    // -------------------------------------------------------
    // Challenge 1 — Union Types
    // -------------------------------------------------------
    {
      id: 'l5-c1-union-types',
      level: 5,
      number: 1,
      title: 'Union Types',
      difficulty: 'easy',
      xp: 10,
      description: [
        'A **union type** allows a value to be one of several types,',
        'written with the `|` operator.',
        '',
        '```ts',
        'let value: string | number;',
        'value = "hello"; // OK',
        'value = 42;      // also OK',
        'value = true;    // Error!',
        '```',
        '',
        'Unions are everywhere in real TypeScript code — any time a',
        'value can be "this OR that", you reach for a union.',
      ].join('\n'),
      mission:
        'Create a type alias `Result` that is `string | number`. Write a function `formatResult(value: Result): string` that returns the value converted to a string. If it is already a string, return it as-is. If it is a number, return it prefixed with `"#"` (e.g., `42` becomes `"#42"`).',
      scaffold: [
        '// TODO: Define a type alias Result = string | number',
        '',
        '// TODO: Write a function formatResult(value: Result): string',
        '// - If value is a string, return it directly',
        '// - If value is a number, return "#" + value (e.g., "#42")',
      ].join('\n'),
      solution: [
        'type Result = string | number;',
        '',
        'function formatResult(value: Result): string {',
        '  if (typeof value === "string") {',
        '    return value;',
        '  }',
        '  return "#" + value;',
        '}',
      ].join('\n'),
      hints: [
        'Define the type with `type Result = string | number;`.',
        'Use `typeof value === "string"` to check if the value is a string at runtime.',
        'In the number branch, concatenate "#" with the number: `"#" + value`.',
      ],
      tests: [
        {
          description: 'formatResult returns strings as-is',
          test: 'formatResult("hello") === "hello"',
          errorHint:
            'When value is a string, return it unchanged. formatResult("hello") should be "hello".',
        },
        {
          description: 'formatResult prefixes numbers with #',
          test: 'formatResult(42) === "#42"',
          errorHint:
            'When value is a number, return "#" + value. formatResult(42) should be "#42".',
        },
        {
          description: 'formatResult handles zero correctly',
          test: 'formatResult(0) === "#0"',
          errorHint:
            'Make sure zero is handled — formatResult(0) should return "#0", not a falsy shortcut.',
        },
      ],
    },

    // -------------------------------------------------------
    // Challenge 2 — Discriminated Unions
    // -------------------------------------------------------
    {
      id: 'l5-c2-discriminated-unions',
      level: 5,
      number: 2,
      title: 'Discriminated Unions',
      difficulty: 'medium',
      xp: 25,
      description: [
        'A **discriminated union** uses a common literal property (the',
        '"discriminant" or "tag") to distinguish between variants.',
        '',
        '```ts',
        'interface Circle  { kind: "circle";  radius: number }',
        'interface Square  { kind: "square";  side: number }',
        'type Shape = Circle | Square;',
        '',
        'function area(s: Shape) {',
        '  switch (s.kind) {',
        '    case "circle": return Math.PI * s.radius ** 2;',
        '    case "square": return s.side ** 2;',
        '  }',
        '}',
        '```',
        '',
        'The `kind` property is the discriminant — TypeScript narrows the',
        'type inside each branch automatically.',
      ].join('\n'),
      mission: [
        'Create a discriminated union for notification types:',
        '',
        '1. `EmailNotification` with `type: "email"`, `emailAddress: string`, and `subject: string`.',
        '2. `SmsNotification` with `type: "sms"`, `phoneNumber: string`, and `message: string`.',
        '3. `PushNotification` with `type: "push"`, `deviceId: string`, and `title: string`.',
        '4. Type alias `Notification = EmailNotification | SmsNotification | PushNotification`.',
        '5. Function `getRecipient(n: Notification): string` that returns the recipient identifier — `emailAddress`, `phoneNumber`, or `deviceId` depending on the type.',
      ].join('\n'),
      scaffold: [
        '// TODO: Define interface EmailNotification',
        '//   type: "email", emailAddress: string, subject: string',
        '',
        '// TODO: Define interface SmsNotification',
        '//   type: "sms", phoneNumber: string, message: string',
        '',
        '// TODO: Define interface PushNotification',
        '//   type: "push", deviceId: string, title: string',
        '',
        '// TODO: Define type Notification = EmailNotification | SmsNotification | PushNotification',
        '',
        '// TODO: Write function getRecipient(n: Notification): string',
        '// Return the appropriate recipient for each notification type',
      ].join('\n'),
      solution: [
        'interface EmailNotification {',
        '  type: "email";',
        '  emailAddress: string;',
        '  subject: string;',
        '}',
        '',
        'interface SmsNotification {',
        '  type: "sms";',
        '  phoneNumber: string;',
        '  message: string;',
        '}',
        '',
        'interface PushNotification {',
        '  type: "push";',
        '  deviceId: string;',
        '  title: string;',
        '}',
        '',
        'type Notification = EmailNotification | SmsNotification | PushNotification;',
        '',
        'function getRecipient(n: Notification): string {',
        '  switch (n.type) {',
        '    case "email": return n.emailAddress;',
        '    case "sms":   return n.phoneNumber;',
        '    case "push":  return n.deviceId;',
        '  }',
        '}',
      ].join('\n'),
      hints: [
        'Each interface needs a `type` property with a string literal type (e.g., `type: "email"`).',
        'Use a `switch` statement on `n.type` — TypeScript narrows the type in each `case` branch.',
        'In each branch, return the correct identifier: `n.emailAddress`, `n.phoneNumber`, or `n.deviceId`.',
      ],
      tests: [
        {
          description: 'getRecipient returns emailAddress for email notifications',
          test: 'getRecipient({ type: "email", emailAddress: "a@b.com", subject: "Hi" }) === "a@b.com"',
          errorHint:
            'For email notifications, return the `emailAddress` property.',
        },
        {
          description: 'getRecipient returns phoneNumber for sms notifications',
          test: 'getRecipient({ type: "sms", phoneNumber: "+1234", message: "Hey" }) === "+1234"',
          errorHint:
            'For sms notifications, return the `phoneNumber` property.',
        },
        {
          description: 'getRecipient returns deviceId for push notifications',
          test: 'getRecipient({ type: "push", deviceId: "dev-99", title: "Alert" }) === "dev-99"',
          errorHint:
            'For push notifications, return the `deviceId` property.',
        },
      ],
    },

    // -------------------------------------------------------
    // Challenge 3 — Type Guards
    // -------------------------------------------------------
    {
      id: 'l5-c3-type-guards',
      level: 5,
      number: 3,
      title: 'Type Guards',
      difficulty: 'medium',
      xp: 25,
      description: [
        'TypeScript can **narrow** a union type based on runtime checks',
        'called type guards. The built-in guards are:',
        '',
        '- `typeof x === "string"` — narrows to primitive types',
        '- `x instanceof Date` — narrows to class instances',
        '- `"prop" in obj` — narrows based on property existence',
        '',
        '```ts',
        'function process(input: string | string[]) {',
        '  if (Array.isArray(input)) {',
        '    // input is string[] here',
        '    return input.join(", ");',
        '  }',
        '  // input is string here',
        '  return input.toUpperCase();',
        '}',
        '```',
        '',
        'After a type guard, TypeScript knows the narrowed type in',
        'each branch — no casting needed!',
      ].join('\n'),
      mission: [
        'Write three functions that demonstrate different type guards:',
        '',
        '1. `stringify(value: string | number | boolean): string` — use `typeof` to handle each type:',
        '   - string: return as-is',
        '   - number: return `value.toFixed(2)`',
        '   - boolean: return `"yes"` or `"no"`',
        '',
        '2. `getLength(value: string | string[]): number` — use `Array.isArray` to return the length',
        '   of the string or the array.',
        '',
        '3. `describe(obj: { name: string } | { title: string }): string` — use the `in` operator',
        '   to check for `"name"` or `"title"` and return whichever exists.',
      ].join('\n'),
      scaffold: [
        '// TODO: Write function stringify(value: string | number | boolean): string',
        '// Use typeof guards for each type',
        '',
        '// TODO: Write function getLength(value: string | string[]): number',
        '// Use Array.isArray to distinguish between string and string[]',
        '',
        '// TODO: Write function describe(obj: { name: string } | { title: string }): string',
        '// Use the `in` operator to check for "name" or "title"',
      ].join('\n'),
      solution: [
        'function stringify(value: string | number | boolean): string {',
        '  if (typeof value === "string") {',
        '    return value;',
        '  }',
        '  if (typeof value === "number") {',
        '    return value.toFixed(2);',
        '  }',
        '  return value ? "yes" : "no";',
        '}',
        '',
        'function getLength(value: string | string[]): number {',
        '  if (Array.isArray(value)) {',
        '    return value.length;',
        '  }',
        '  return value.length;',
        '}',
        '',
        'function describe(obj: { name: string } | { title: string }): string {',
        '  if ("name" in obj) {',
        '    return obj.name;',
        '  }',
        '  return obj.title;',
        '}',
      ].join('\n'),
      hints: [
        'For `stringify`, chain `typeof` checks: `typeof value === "string"`, then `typeof value === "number"`, and the remaining case is boolean.',
        'For `getLength`, use `Array.isArray(value)` — both strings and arrays have a `.length` property, but TypeScript needs to know which one.',
        'For `describe`, use `"name" in obj` to check if the object has a `name` property.',
      ],
      tests: [
        {
          description: 'stringify handles strings',
          test: 'stringify("hello") === "hello"',
          errorHint: 'stringify("hello") should return "hello".',
        },
        {
          description: 'stringify handles numbers with toFixed(2)',
          test: 'stringify(3.1) === "3.10"',
          errorHint:
            'stringify(3.1) should return "3.10" — use value.toFixed(2).',
        },
        {
          description: 'stringify handles booleans',
          test: 'stringify(true) === "yes" && stringify(false) === "no"',
          errorHint:
            'stringify(true) should return "yes" and stringify(false) should return "no".',
        },
        {
          description: 'getLength works for strings and arrays',
          test: 'getLength("abc") === 3 && getLength(["a", "b"]) === 2',
          errorHint:
            'getLength("abc") should be 3 and getLength(["a","b"]) should be 2.',
        },
        {
          description: 'describe extracts the right property',
          test: 'describe({ name: "Alice" }) === "Alice" && describe({ title: "Boss" }) === "Boss"',
          errorHint:
            'describe should return `name` if it exists, otherwise `title`.',
        },
      ],
    },

    // -------------------------------------------------------
    // Challenge 4 — Custom Type Guards
    // -------------------------------------------------------
    {
      id: 'l5-c4-custom-type-guards',
      level: 5,
      number: 4,
      title: 'Custom Type Guards',
      difficulty: 'hard',
      xp: 50,
      description: [
        'Sometimes built-in checks are not enough. You can write a',
        '**custom type guard** using the `is` keyword in the return type.',
        '',
        '```ts',
        'function isString(value: unknown): value is string {',
        '  return typeof value === "string";',
        '}',
        '',
        'function process(x: unknown) {',
        '  if (isString(x)) {',
        '    // x is string here!',
        '    console.log(x.toUpperCase());',
        '  }',
        '}',
        '```',
        '',
        'The return type `value is string` tells TypeScript: "if this',
        'function returns true, narrow the argument to `string`."',
      ].join('\n'),
      mission: [
        'Create the following type guard functions:',
        '',
        '1. Interface `Cat` with `meow(): string` and interface `Dog` with `bark(): string`.',
        '2. Type alias `Pet = Cat | Dog`.',
        '3. `function isCat(pet: Pet): pet is Cat` — returns true if `pet` has a `meow` method.',
        '4. `function isDog(pet: Pet): pet is Dog` — returns true if `pet` has a `bark` method.',
        '5. `function petSound(pet: Pet): string` — uses your guards to call the right method.',
      ].join('\n'),
      scaffold: [
        '// TODO: Define interface Cat with meow(): string',
        '',
        '// TODO: Define interface Dog with bark(): string',
        '',
        '// TODO: Define type Pet = Cat | Dog',
        '',
        '// TODO: Write type guard isCat(pet: Pet): pet is Cat',
        '// Hint: check if "meow" exists in the pet object',
        '',
        '// TODO: Write type guard isDog(pet: Pet): pet is Dog',
        '// Hint: check if "bark" exists in the pet object',
        '',
        '// TODO: Write function petSound(pet: Pet): string',
        '// Use isCat/isDog to call the appropriate method',
      ].join('\n'),
      solution: [
        'interface Cat {',
        '  meow(): string;',
        '}',
        '',
        'interface Dog {',
        '  bark(): string;',
        '}',
        '',
        'type Pet = Cat | Dog;',
        '',
        'function isCat(pet: Pet): pet is Cat {',
        '  return "meow" in pet;',
        '}',
        '',
        'function isDog(pet: Pet): pet is Dog {',
        '  return "bark" in pet;',
        '}',
        '',
        'function petSound(pet: Pet): string {',
        '  if (isCat(pet)) {',
        '    return pet.meow();',
        '  }',
        '  return pet.bark();',
        '}',
      ].join('\n'),
      hints: [
        'Custom type guards use the syntax `pet is Cat` as the return type — this is what tells TypeScript to narrow the type.',
        'Check for the method using `"meow" in pet` — the `in` operator checks if a property exists on an object.',
        'In `petSound`, call `isCat(pet)` first. Inside that branch, TypeScript knows `pet` is a `Cat` so you can call `pet.meow()`.',
      ],
      tests: [
        {
          description: 'isCat correctly identifies cats',
          test: [
            '(() => {',
            '  const cat: Pet = { meow: () => "meow!" };',
            '  const dog: Pet = { bark: () => "woof!" };',
            '  return isCat(cat) === true && isCat(dog) === false;',
            '})()',
          ].join('\n'),
          errorHint:
            'isCat should return true for objects with a `meow` method and false otherwise.',
        },
        {
          description: 'isDog correctly identifies dogs',
          test: [
            '(() => {',
            '  const cat: Pet = { meow: () => "meow!" };',
            '  const dog: Pet = { bark: () => "woof!" };',
            '  return isDog(dog) === true && isDog(cat) === false;',
            '})()',
          ].join('\n'),
          errorHint:
            'isDog should return true for objects with a `bark` method and false otherwise.',
        },
        {
          description: 'petSound calls the correct method',
          test: [
            '(() => {',
            '  const cat: Pet = { meow: () => "purr" };',
            '  const dog: Pet = { bark: () => "woof" };',
            '  return petSound(cat) === "purr" && petSound(dog) === "woof";',
            '})()',
          ].join('\n'),
          errorHint:
            'petSound should use isCat/isDog to call pet.meow() or pet.bark() and return the result.',
        },
      ],
    },

    // -------------------------------------------------------
    // Challenge 5 — Exhaustive Checks
    // -------------------------------------------------------
    {
      id: 'l5-c5-exhaustive-checks',
      level: 5,
      number: 5,
      title: 'Exhaustive Checks',
      difficulty: 'hard',
      xp: 50,
      description: [
        'The `never` type represents values that should never occur.',
        'You can use it for **exhaustive checking** — ensuring you handle',
        'every variant of a union.',
        '',
        '```ts',
        'type Color = "red" | "green" | "blue";',
        '',
        'function colorToHex(c: Color): string {',
        '  switch (c) {',
        '    case "red":   return "#ff0000";',
        '    case "green": return "#00ff00";',
        '    case "blue":  return "#0000ff";',
        '    default:',
        '      // If all cases are handled, c is `never` here.',
        '      // If you add a new Color but forget to handle it,',
        '      // TypeScript will report an error at compile time!',
        '      const _exhaustive: never = c;',
        '      return _exhaustive;',
        '  }',
        '}',
        '```',
        '',
        'This pattern catches missing cases at **compile time**, not runtime.',
      ].join('\n'),
      mission: [
        'Create a discriminated union and an exhaustive handler:',
        '',
        '1. Define `type Direction = "north" | "south" | "east" | "west"`.',
        '2. Write a helper function `assertNever(value: never): never` that throws an Error with message `"Unexpected value: <value>"`.',
        '3. Write `function move(direction: Direction): { x: number; y: number }` that returns:',
        '   - north: `{ x: 0, y: 1 }`',
        '   - south: `{ x: 0, y: -1 }`',
        '   - east: `{ x: 1, y: 0 }`',
        '   - west: `{ x: -1, y: 0 }`',
        '   - default: call `assertNever(direction)` for exhaustive checking.',
      ].join('\n'),
      scaffold: [
        '// TODO: Define type Direction = "north" | "south" | "east" | "west"',
        '',
        '// TODO: Write function assertNever(value: never): never',
        '// It should throw an Error with message "Unexpected value: <value>"',
        '',
        '// TODO: Write function move(direction: Direction): { x: number; y: number }',
        '// Use a switch statement with all four directions',
        '// In the default case, call assertNever(direction)',
      ].join('\n'),
      solution: [
        'type Direction = "north" | "south" | "east" | "west";',
        '',
        'function assertNever(value: never): never {',
        '  throw new Error(`Unexpected value: ${value}`);',
        '}',
        '',
        'function move(direction: Direction): { x: number; y: number } {',
        '  switch (direction) {',
        '    case "north": return { x: 0, y: 1 };',
        '    case "south": return { x: 0, y: -1 };',
        '    case "east":  return { x: 1, y: 0 };',
        '    case "west":  return { x: -1, y: 0 };',
        '    default: return assertNever(direction);',
        '  }',
        '}',
      ].join('\n'),
      hints: [
        'Define the union as a set of string literals: `type Direction = "north" | "south" | "east" | "west";`',
        'assertNever takes `never` and throws — it should never actually be called if all cases are handled.',
        'In the `default` branch of move, call `assertNever(direction)`. If all cases are covered, TypeScript knows `direction` is `never` there.',
      ],
      tests: [
        {
          description: 'move returns correct deltas for each direction',
          test: [
            '(() => {',
            '  const n = move("north"), s = move("south");',
            '  const e = move("east"),  w = move("west");',
            '  return n.x === 0 && n.y === 1',
            '    && s.x === 0 && s.y === -1',
            '    && e.x === 1 && e.y === 0',
            '    && w.x === -1 && w.y === 0;',
            '})()',
          ].join('\n'),
          errorHint:
            'Check your return values: north=(0,1), south=(0,-1), east=(1,0), west=(-1,0).',
        },
        {
          description: 'assertNever throws on unexpected values',
          test: [
            '(() => {',
            '  try {',
            '    assertNever("oops" as never);',
            '    return false;',
            '  } catch (e) {',
            '    return (e as Error).message === "Unexpected value: oops";',
            '  }',
            '})()',
          ].join('\n'),
          errorHint:
            'assertNever should throw an Error with message "Unexpected value: <value>".',
        },
      ],
    },

    // -------------------------------------------------------
    // Challenge 6 — BOSS: The Shape Shifter
    // -------------------------------------------------------
    {
      id: 'l5-c6-boss-shape-shifter',
      level: 5,
      number: 6,
      title: 'BOSS: The Shape Shifter',
      difficulty: 'boss',
      xp: 200,
      description: [
        '## BOSS BATTLE: The Shape Shifter',
        '',
        'A complex UI component can be in many states: loading, error,',
        'success, or empty. Modeling this as a discriminated union with',
        'proper narrowing prevents entire categories of bugs.',
        '',
        'In this boss challenge, you will design a type-safe state',
        'machine for an async data-fetching component. Every state',
        'transition must be accounted for — no escape!',
      ].join('\n'),
      mission: [
        'Build a complete async state machine:',
        '',
        '1. Define four state interfaces, all with a discriminant property `status`:',
        '   - `IdleState`: `status: "idle"`',
        '   - `LoadingState`: `status: "loading"`, `startedAt: number`',
        '   - `ErrorState`: `status: "error"`, `error: string`, `retryCount: number`',
        '   - `SuccessState<T>`: `status: "success"`, `data: T`, `fetchedAt: number`',
        '',
        '2. Type alias `AsyncState<T> = IdleState | LoadingState | ErrorState | SuccessState<T>`.',
        '',
        '3. Function `getStatusMessage<T>(state: AsyncState<T>): string`:',
        '   - idle: `"Waiting to start"`',
        '   - loading: `"Loading..."`',
        '   - error: `"Error: <error> (retry #<retryCount>)"`',
        '   - success: `"Data loaded successfully"`',
        '   - Use exhaustive checking with a `never` default.',
        '',
        '4. Function `transition<T>(state: AsyncState<T>, action: Action): AsyncState<T>` where `Action` is:',
        '   - `{ type: "fetch" }` — moves from any state to loading (with `startedAt: Date.now()`)',
        '   - `{ type: "success"; data: T }` — moves from loading to success (with `fetchedAt: Date.now()`)',
        '   - `{ type: "error"; error: string }` — moves from loading to error (with `retryCount` starting at 1, or incrementing if already in error)',
        '   - `{ type: "reset" }` — moves from any state to idle',
        '',
        '5. A type guard `isLoaded<T>(state: AsyncState<T>): state is SuccessState<T>`.',
      ].join('\n'),
      scaffold: [
        '// TODO 1: Define IdleState, LoadingState, ErrorState, SuccessState<T>',
        '',
        '// TODO 2: Define type AsyncState<T>',
        '',
        '// TODO 3: Define Action type',
        '//   { type: "fetch" }',
        '//   { type: "success"; data: T } — hint: make Action generic too',
        '//   { type: "error"; error: string }',
        '//   { type: "reset" }',
        '',
        '// TODO 4: Write getStatusMessage<T>(state: AsyncState<T>): string',
        '// Use a switch on state.status with exhaustive checking',
        '',
        '// TODO 5: Write transition<T>(state: AsyncState<T>, action: Action<T>): AsyncState<T>',
        '// Handle all action types, return the appropriate new state',
        '',
        '// TODO 6: Write type guard isLoaded<T>(state: AsyncState<T>): state is SuccessState<T>',
      ].join('\n'),
      solution: [
        'interface IdleState {',
        '  status: "idle";',
        '}',
        '',
        'interface LoadingState {',
        '  status: "loading";',
        '  startedAt: number;',
        '}',
        '',
        'interface ErrorState {',
        '  status: "error";',
        '  error: string;',
        '  retryCount: number;',
        '}',
        '',
        'interface SuccessState<T> {',
        '  status: "success";',
        '  data: T;',
        '  fetchedAt: number;',
        '}',
        '',
        'type AsyncState<T> = IdleState | LoadingState | ErrorState | SuccessState<T>;',
        '',
        'type Action<T> =',
        '  | { type: "fetch" }',
        '  | { type: "success"; data: T }',
        '  | { type: "error"; error: string }',
        '  | { type: "reset" };',
        '',
        'function getStatusMessage<T>(state: AsyncState<T>): string {',
        '  switch (state.status) {',
        '    case "idle":    return "Waiting to start";',
        '    case "loading": return "Loading...";',
        '    case "error":   return `Error: ${state.error} (retry #${state.retryCount})`;',
        '    case "success": return "Data loaded successfully";',
        '    default: {',
        '      const _exhaustive: never = state;',
        '      return _exhaustive;',
        '    }',
        '  }',
        '}',
        '',
        'function transition<T>(state: AsyncState<T>, action: Action<T>): AsyncState<T> {',
        '  switch (action.type) {',
        '    case "fetch":',
        '      return { status: "loading", startedAt: Date.now() };',
        '    case "success":',
        '      return { status: "success", data: action.data, fetchedAt: Date.now() };',
        '    case "error": {',
        '      const retryCount = state.status === "error" ? state.retryCount + 1 : 1;',
        '      return { status: "error", error: action.error, retryCount };',
        '    }',
        '    case "reset":',
        '      return { status: "idle" };',
        '  }',
        '}',
        '',
        'function isLoaded<T>(state: AsyncState<T>): state is SuccessState<T> {',
        '  return state.status === "success";',
        '}',
      ].join('\n'),
      hints: [
        'Start with the four state interfaces. Each needs a `status` property with a string literal type for discrimination.',
        'Make `Action` generic too: `type Action<T> = { type: "fetch" } | { type: "success"; data: T } | ...`. This way `transition` can receive typed success data.',
        'In `transition`, for the "error" action, check if the current state is already "error" to increment retryCount: `state.status === "error" ? state.retryCount + 1 : 1`.',
      ],
      tests: [
        {
          description: 'getStatusMessage returns correct messages',
          test: [
            '(() => {',
            '  const idle: AsyncState<string> = { status: "idle" };',
            '  const loading: AsyncState<string> = { status: "loading", startedAt: 0 };',
            '  const error: AsyncState<string> = { status: "error", error: "timeout", retryCount: 2 };',
            '  const success: AsyncState<string> = { status: "success", data: "hi", fetchedAt: 0 };',
            '  return getStatusMessage(idle) === "Waiting to start"',
            '    && getStatusMessage(loading) === "Loading..."',
            '    && getStatusMessage(error) === "Error: timeout (retry #2)"',
            '    && getStatusMessage(success) === "Data loaded successfully";',
            '})()',
          ].join('\n'),
          errorHint:
            'Check each status message format carefully. Error format: "Error: <error> (retry #<retryCount>)".',
        },
        {
          description: 'transition handles fetch and reset actions',
          test: [
            '(() => {',
            '  const idle: AsyncState<number> = { status: "idle" };',
            '  const loading = transition(idle, { type: "fetch" });',
            '  const reset = transition(loading, { type: "reset" });',
            '  return loading.status === "loading"',
            '    && "startedAt" in loading',
            '    && reset.status === "idle";',
            '})()',
          ].join('\n'),
          errorHint:
            'transition with "fetch" should produce a LoadingState. "reset" should produce IdleState.',
        },
        {
          description: 'transition handles success action',
          test: [
            '(() => {',
            '  const loading: AsyncState<string> = { status: "loading", startedAt: 0 };',
            '  const success = transition(loading, { type: "success", data: "result" });',
            '  return success.status === "success"',
            '    && "data" in success && (success as any).data === "result"',
            '    && "fetchedAt" in success;',
            '})()',
          ].join('\n'),
          errorHint:
            'transition with "success" should produce a SuccessState containing the provided data and a fetchedAt timestamp.',
        },
        {
          description: 'transition increments retryCount on repeated errors',
          test: [
            '(() => {',
            '  const loading: AsyncState<string> = { status: "loading", startedAt: 0 };',
            '  const err1 = transition(loading, { type: "error", error: "fail" });',
            '  const err2 = transition(err1, { type: "error", error: "fail again" });',
            '  return err1.status === "error" && (err1 as any).retryCount === 1',
            '    && err2.status === "error" && (err2 as any).retryCount === 2;',
            '})()',
          ].join('\n'),
          errorHint:
            'First error should have retryCount 1. A second error (from error state) should increment to 2.',
        },
        {
          description: 'isLoaded type guard works correctly',
          test: [
            '(() => {',
            '  const success: AsyncState<number> = { status: "success", data: 42, fetchedAt: 0 };',
            '  const loading: AsyncState<number> = { status: "loading", startedAt: 0 };',
            '  return isLoaded(success) === true && isLoaded(loading) === false;',
            '})()',
          ].join('\n'),
          errorHint:
            'isLoaded should return true only when state.status === "success".',
        },
      ],
    },
  ],
};
