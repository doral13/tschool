import { LevelDefinition } from '../../engine/types';

export const level04: LevelDefinition = {
  number: 4,
  title: 'Interfaces & Type Aliases',
  description:
    'Learn to define the shape of your data with interfaces and type aliases — the blueprints of every TypeScript project.',
  challenges: [
    // -------------------------------------------------------
    // Challenge 1 — Your First Interface
    // -------------------------------------------------------
    {
      id: 'L4-C1',
      level: 4,
      number: 1,
      title: 'Your First Interface',
      difficulty: 'easy',
      xp: 10,
      description: [
        'An **interface** describes the shape of an object. It tells TypeScript',
        'which properties exist and what types they hold.',
        '',
        '```ts',
        'interface User {',
        '  name: string;',
        '  age: number;',
        '}',
        '```',
        '',
        'Once declared, you can use the interface as a type annotation.',
        'TypeScript will ensure every object assigned to that type has the',
        'correct properties.',
      ].join('\n'),
      mission:
        'Define an interface `Product` with properties `name` (string), `price` (number), and `inStock` (boolean). Then create a variable `myProduct` of type `Product` with any valid values.',
      scaffold: [
        '// TODO: Define an interface called Product',
        '// It should have:',
        '//   name   - string',
        '//   price  - number',
        '//   inStock - boolean',
        '',
        '// TODO: Create a variable `myProduct` of type Product',
      ].join('\n'),
      solution: [
        'interface Product {',
        '  name: string;',
        '  price: number;',
        '  inStock: boolean;',
        '}',
        '',
        'const myProduct: Product = {',
        '  name: "Widget",',
        '  price: 9.99,',
        '  inStock: true,',
        '};',
      ].join('\n'),
      hints: [
        'Use the `interface` keyword followed by the name and a block with property declarations.',
        'Each property is written as `propertyName: Type;` inside the interface body.',
        'Create the variable with `const myProduct: Product = { ... };` and fill in all three properties.',
      ],
      tests: [
        {
          description: 'Product interface exists and myProduct has a string name',
          test: 'typeof myProduct.name === "string"',
          errorHint:
            'Make sure `myProduct` has a `name` property of type string.',
        },
        {
          description: 'myProduct has a numeric price',
          test: 'typeof myProduct.price === "number"',
          errorHint:
            'Make sure `myProduct` has a `price` property of type number.',
        },
        {
          description: 'myProduct has a boolean inStock',
          test: 'typeof myProduct.inStock === "boolean"',
          errorHint:
            'Make sure `myProduct` has an `inStock` property of type boolean.',
        },
      ],
    },

    // -------------------------------------------------------
    // Challenge 2 — Extending Interfaces
    // -------------------------------------------------------
    {
      id: 'L4-C2',
      level: 4,
      number: 2,
      title: 'Extending Interfaces',
      difficulty: 'easy',
      xp: 10,
      description: [
        'Interfaces can **extend** other interfaces, inheriting all their',
        'properties and adding new ones.',
        '',
        '```ts',
        'interface Animal {',
        '  name: string;',
        '}',
        '',
        'interface Dog extends Animal {',
        '  breed: string;',
        '}',
        '```',
        '',
        'A `Dog` has both `name` (from `Animal`) and `breed`.',
        'You can extend multiple interfaces by separating them with commas.',
      ].join('\n'),
      mission:
        'Create an interface `BaseEntity` with `id` (number) and `createdAt` (string). Then create an interface `User` that extends `BaseEntity` and adds `username` (string) and `email` (string). Finally, create a `sampleUser` variable of type `User`.',
      scaffold: [
        '// TODO: Define a BaseEntity interface',
        '//   id        - number',
        '//   createdAt - string',
        '',
        '// TODO: Define a User interface that extends BaseEntity',
        '//   username - string',
        '//   email    - string',
        '',
        '// TODO: Create a variable `sampleUser` of type User',
      ].join('\n'),
      solution: [
        'interface BaseEntity {',
        '  id: number;',
        '  createdAt: string;',
        '}',
        '',
        'interface User extends BaseEntity {',
        '  username: string;',
        '  email: string;',
        '}',
        '',
        'const sampleUser: User = {',
        '  id: 1,',
        '  createdAt: "2025-01-01",',
        '  username: "tschooler",',
        '  email: "learn@tschool.dev",',
        '};',
      ].join('\n'),
      hints: [
        'Define `BaseEntity` first with `id` and `createdAt`.',
        'Use `interface User extends BaseEntity { ... }` to inherit from BaseEntity.',
        '`sampleUser` must include all four properties: `id`, `createdAt`, `username`, and `email`.',
      ],
      tests: [
        {
          description: 'sampleUser has an id (number) and createdAt (string)',
          test: 'typeof sampleUser.id === "number" && typeof sampleUser.createdAt === "string"',
          errorHint:
            'sampleUser must have `id` (number) and `createdAt` (string) inherited from BaseEntity.',
        },
        {
          description: 'sampleUser has username and email',
          test: 'typeof sampleUser.username === "string" && typeof sampleUser.email === "string"',
          errorHint:
            'sampleUser must have `username` (string) and `email` (string) from User.',
        },
      ],
    },

    // -------------------------------------------------------
    // Challenge 3 — Type Aliases
    // -------------------------------------------------------
    {
      id: 'L4-C3',
      level: 4,
      number: 3,
      title: 'Type Aliases',
      difficulty: 'medium',
      xp: 25,
      description: [
        'A **type alias** creates a new name for any type using the `type` keyword.',
        '',
        '```ts',
        'type ID = string | number;',
        'type Coordinate = { x: number; y: number };',
        '```',
        '',
        '**When to use `type` vs `interface`?**',
        '- Use `interface` when defining object shapes that may be extended.',
        '- Use `type` for unions, intersections, tuples, or when you need',
        '  to alias primitives.',
        '',
        'Both can describe object shapes, but only `type` can represent',
        'unions and mapped types, while only `interface` supports',
        'declaration merging.',
      ].join('\n'),
      mission:
        'Create a type alias `StringOrNumber` for `string | number`. Create a type alias `Point` for an object with `x` and `y` (both numbers). Create a type alias `Pair<T>` that represents a tuple `[T, T]`. Create variables `myId: StringOrNumber`, `origin: Point`, and `twins: Pair<string>` with valid values.',
      scaffold: [
        '// TODO: Create a type alias StringOrNumber (string | number)',
        '',
        '// TODO: Create a type alias Point ({ x: number; y: number })',
        '',
        '// TODO: Create a generic type alias Pair<T> that is a tuple [T, T]',
        '',
        '// TODO: Create variable myId of type StringOrNumber',
        '',
        '// TODO: Create variable origin of type Point',
        '',
        '// TODO: Create variable twins of type Pair<string>',
      ].join('\n'),
      solution: [
        'type StringOrNumber = string | number;',
        '',
        'type Point = { x: number; y: number };',
        '',
        'type Pair<T> = [T, T];',
        '',
        'const myId: StringOrNumber = 42;',
        '',
        'const origin: Point = { x: 0, y: 0 };',
        '',
        'const twins: Pair<string> = ["hello", "world"];',
      ].join('\n'),
      hints: [
        'Use `type StringOrNumber = string | number;` — the `type` keyword creates an alias.',
        'A generic type alias looks like `type Pair<T> = [T, T];` — the angle brackets define a type parameter.',
        'For `twins`, provide a tuple with exactly two string values: `["a", "b"]`.',
      ],
      tests: [
        {
          description: 'myId is a string or number',
          test: '(typeof myId === "string" || typeof myId === "number")',
          errorHint:
            'myId should be of type StringOrNumber — assign it a string or number value.',
        },
        {
          description: 'origin is a Point with x and y as numbers',
          test: 'typeof origin.x === "number" && typeof origin.y === "number"',
          errorHint:
            'origin must be a Point object with numeric `x` and `y` properties.',
        },
        {
          description: 'twins is a pair of strings (tuple with 2 elements)',
          test: 'Array.isArray(twins) && twins.length === 2 && typeof twins[0] === "string" && typeof twins[1] === "string"',
          errorHint:
            'twins should be a Pair<string> — a tuple with exactly two string elements.',
        },
      ],
    },

    // -------------------------------------------------------
    // Challenge 4 — Intersection Types
    // -------------------------------------------------------
    {
      id: 'L4-C4',
      level: 4,
      number: 4,
      title: 'Intersection Types',
      difficulty: 'medium',
      xp: 25,
      description: [
        'An **intersection type** combines multiple types into one using `&`.',
        'The resulting type has all properties from every constituent type.',
        '',
        '```ts',
        'type HasName = { name: string };',
        'type HasAge  = { age: number };',
        'type Person  = HasName & HasAge;',
        '// Person has both name AND age',
        '```',
        '',
        'Intersections are powerful for composing types from smaller,',
        'reusable pieces — like mixing in capabilities.',
      ].join('\n'),
      mission:
        'Define three type aliases: `Timestamped` with `createdAt: string` and `updatedAt: string`; `Identifiable` with `id: number`; and `SoftDeletable` with `deletedAt: string | null`. Then create an intersection type `DatabaseRecord` that combines all three. Create a variable `record` of type `DatabaseRecord`.',
      scaffold: [
        '// TODO: Define type Timestamped  (createdAt: string, updatedAt: string)',
        '',
        '// TODO: Define type Identifiable (id: number)',
        '',
        '// TODO: Define type SoftDeletable (deletedAt: string | null)',
        '',
        '// TODO: Create intersection type DatabaseRecord = Timestamped & Identifiable & SoftDeletable',
        '',
        '// TODO: Create a variable `record` of type DatabaseRecord',
      ].join('\n'),
      solution: [
        'type Timestamped = { createdAt: string; updatedAt: string };',
        '',
        'type Identifiable = { id: number };',
        '',
        'type SoftDeletable = { deletedAt: string | null };',
        '',
        'type DatabaseRecord = Timestamped & Identifiable & SoftDeletable;',
        '',
        'const record: DatabaseRecord = {',
        '  id: 1,',
        '  createdAt: "2025-01-01",',
        '  updatedAt: "2025-06-15",',
        '  deletedAt: null,',
        '};',
      ].join('\n'),
      hints: [
        'Define each type separately first: `type Timestamped = { createdAt: string; updatedAt: string };`',
        'Combine them with `&`: `type DatabaseRecord = Timestamped & Identifiable & SoftDeletable;`',
        'The `record` variable needs all five properties: `id`, `createdAt`, `updatedAt`, and `deletedAt`.',
      ],
      tests: [
        {
          description: 'record has Identifiable properties',
          test: 'typeof record.id === "number"',
          errorHint: 'record must have an `id` property of type number.',
        },
        {
          description: 'record has Timestamped properties',
          test: 'typeof record.createdAt === "string" && typeof record.updatedAt === "string"',
          errorHint:
            'record must have `createdAt` and `updatedAt` as strings.',
        },
        {
          description: 'record has SoftDeletable properties',
          test: 'record.deletedAt === null || typeof record.deletedAt === "string"',
          errorHint:
            'record must have `deletedAt` as either a string or null.',
        },
      ],
    },

    // -------------------------------------------------------
    // Challenge 5 — Declaration Merging
    // -------------------------------------------------------
    {
      id: 'L4-C5',
      level: 4,
      number: 5,
      title: 'Declaration Merging',
      difficulty: 'hard',
      xp: 50,
      description: [
        '**Declaration merging** is a unique interface feature. When you',
        'declare an interface with the same name twice, TypeScript merges',
        'them into a single interface.',
        '',
        '```ts',
        'interface Config {',
        '  host: string;',
        '}',
        'interface Config {',
        '  port: number;',
        '}',
        '// Config now has BOTH host and port',
        '```',
        '',
        'This is used extensively in library type definitions (`.d.ts` files)',
        'to extend existing types. Note that `type` aliases do **not**',
        'support declaration merging — this is a key difference.',
      ].join('\n'),
      mission:
        'Create an interface `Window` with property `appName: string`. Then declare the same interface `Window` again and add `appVersion: number`. Create a variable `appWindow` of type `Window` that satisfies the merged interface. Also create a function `describeWindow` that takes a `Window` parameter and returns a string like `"<appName> v<appVersion>"`.',
      scaffold: [
        '// TODO: Declare an interface Window with appName: string',
        '',
        '// TODO: Declare interface Window again with appVersion: number',
        '// (TypeScript will merge both declarations!)',
        '',
        '// TODO: Create a variable `appWindow` of type Window',
        '// It must have BOTH appName and appVersion',
        '',
        '// TODO: Create a function describeWindow(w: Window): string',
        '// Return a string like "MyApp v2"',
      ].join('\n'),
      solution: [
        'interface Window {',
        '  appName: string;',
        '}',
        '',
        'interface Window {',
        '  appVersion: number;',
        '}',
        '',
        'const appWindow: Window = {',
        '  appName: "TSchool",',
        '  appVersion: 1,',
        '};',
        '',
        'function describeWindow(w: Window): string {',
        '  return `${w.appName} v${w.appVersion}`;',
        '}',
      ].join('\n'),
      hints: [
        'Simply write `interface Window { ... }` twice — TypeScript merges them automatically.',
        'The merged `Window` requires both `appName` and `appVersion`, so `appWindow` needs both.',
        'Use a template literal for `describeWindow`: `` return `${w.appName} v${w.appVersion}`; ``',
      ],
      tests: [
        {
          description: 'appWindow has both appName and appVersion',
          test: 'typeof appWindow.appName === "string" && typeof appWindow.appVersion === "number"',
          errorHint:
            'appWindow must have `appName` (string) and `appVersion` (number) from the merged interface.',
        },
        {
          description: 'describeWindow returns the correct format',
          test: 'describeWindow({ appName: "TestApp", appVersion: 3 }) === "TestApp v3"',
          errorHint:
            'describeWindow should return `"<appName> v<appVersion>"`. For input { appName: "TestApp", appVersion: 3 } it should return "TestApp v3".',
        },
      ],
    },

    // -------------------------------------------------------
    // Challenge 6 — BOSS: The API Architect
    // -------------------------------------------------------
    {
      id: 'L4-C6',
      level: 4,
      number: 6,
      title: 'BOSS: The API Architect',
      difficulty: 'boss',
      xp: 200,
      description: [
        '## BOSS BATTLE: The API Architect',
        '',
        'You have been hired to design the type system for a REST API.',
        'You will combine everything from this level: interfaces, extends,',
        'type aliases, intersections, and declaration merging.',
        '',
        'A well-designed type system is the backbone of any TypeScript',
        'project. Show your mastery!',
      ].join('\n'),
      mission: [
        'Design a complete API type system:',
        '',
        '1. Create an interface `ApiResponse<T>` with `status` (number), `data` (T), and `timestamp` (string).',
        '2. Create an interface `PaginationInfo` with `page` (number), `perPage` (number), and `total` (number).',
        '3. Create a type alias `PaginatedResponse<T>` that is the intersection of `ApiResponse<T[]>` and `{ pagination: PaginationInfo }`.',
        '4. Create an interface `UserDto` with `id` (number), `name` (string), and `email` (string).',
        '5. Create an interface `PostDto` that extends a type with `id` (number), `title` (string), `body` (string), and `authorId` (number).',
        '6. Create a function `createApiResponse<T>(status: number, data: T): ApiResponse<T>` that returns a valid ApiResponse.',
        '7. Create a function `createPaginatedResponse<T>(items: T[], page: number, perPage: number, total: number): PaginatedResponse<T>` that returns a valid PaginatedResponse.',
      ].join('\n'),
      scaffold: [
        '// TODO 1: Define generic interface ApiResponse<T>',
        '//   status    - number',
        '//   data      - T',
        '//   timestamp - string',
        '',
        '// TODO 2: Define interface PaginationInfo',
        '//   page    - number',
        '//   perPage - number',
        '//   total   - number',
        '',
        '// TODO 3: Define type alias PaginatedResponse<T>',
        '//   Intersection of ApiResponse<T[]> & { pagination: PaginationInfo }',
        '',
        '// TODO 4: Define interface UserDto',
        '//   id    - number',
        '//   name  - string',
        '//   email - string',
        '',
        '// TODO 5: Define interface PostDto',
        '//   id       - number',
        '//   title    - string',
        '//   body     - string',
        '//   authorId - number',
        '',
        '// TODO 6: Implement createApiResponse<T>(status, data) => ApiResponse<T>',
        '',
        '// TODO 7: Implement createPaginatedResponse<T>(items, page, perPage, total) => PaginatedResponse<T>',
      ].join('\n'),
      solution: [
        'interface ApiResponse<T> {',
        '  status: number;',
        '  data: T;',
        '  timestamp: string;',
        '}',
        '',
        'interface PaginationInfo {',
        '  page: number;',
        '  perPage: number;',
        '  total: number;',
        '}',
        '',
        'type PaginatedResponse<T> = ApiResponse<T[]> & { pagination: PaginationInfo };',
        '',
        'interface UserDto {',
        '  id: number;',
        '  name: string;',
        '  email: string;',
        '}',
        '',
        'interface PostDto {',
        '  id: number;',
        '  title: string;',
        '  body: string;',
        '  authorId: number;',
        '}',
        '',
        'function createApiResponse<T>(status: number, data: T): ApiResponse<T> {',
        '  return { status, data, timestamp: new Date().toISOString() };',
        '}',
        '',
        'function createPaginatedResponse<T>(items: T[], page: number, perPage: number, total: number): PaginatedResponse<T> {',
        '  return {',
        '    status: 200,',
        '    data: items,',
        '    timestamp: new Date().toISOString(),',
        '    pagination: { page, perPage, total },',
        '  };',
        '}',
      ].join('\n'),
      hints: [
        'Start with the simpler interfaces (ApiResponse, PaginationInfo, UserDto, PostDto), then build up to the intersection type.',
        'PaginatedResponse combines ApiResponse<T[]> (note the T[] — an array of T) with an object containing pagination. Use `&`.',
        'createApiResponse just returns `{ status, data, timestamp: new Date().toISOString() }`. createPaginatedResponse is similar but adds a `pagination` object.',
      ],
      tests: [
        {
          description: 'createApiResponse returns a valid ApiResponse',
          test: [
            '(() => {',
            '  const res = createApiResponse(200, "hello");',
            '  return res.status === 200 && res.data === "hello" && typeof res.timestamp === "string";',
            '})()',
          ].join('\n'),
          errorHint:
            'createApiResponse(200, "hello") should return { status: 200, data: "hello", timestamp: <string> }.',
        },
        {
          description: 'createApiResponse works with object data',
          test: [
            '(() => {',
            '  const user: UserDto = { id: 1, name: "Alice", email: "alice@test.com" };',
            '  const res = createApiResponse(200, user);',
            '  return res.data.id === 1 && res.data.name === "Alice";',
            '})()',
          ].join('\n'),
          errorHint:
            'createApiResponse should work with any type T, including UserDto objects.',
        },
        {
          description: 'createPaginatedResponse returns valid pagination data',
          test: [
            '(() => {',
            '  const res = createPaginatedResponse(["a", "b"], 1, 10, 2);',
            '  return Array.isArray(res.data) && res.data.length === 2',
            '    && res.pagination.page === 1 && res.pagination.perPage === 10',
            '    && res.pagination.total === 2 && typeof res.timestamp === "string";',
            '})()',
          ].join('\n'),
          errorHint:
            'createPaginatedResponse should return an object with data (array), status, timestamp, and a pagination object with page, perPage, total.',
        },
        {
          description: 'PostDto has all required properties',
          test: [
            '(() => {',
            '  const post: PostDto = { id: 1, title: "Hello", body: "World", authorId: 42 };',
            '  return post.id === 1 && post.title === "Hello" && post.body === "World" && post.authorId === 42;',
            '})()',
          ].join('\n'),
          errorHint:
            'PostDto must have id (number), title (string), body (string), and authorId (number).',
        },
      ],
    },
  ],
};
